pour construire la matrice faire attention au cas ou les lignes n'ont pas la meme taille sur le fichier

// pourqoui M[i][j] fonctionne pas mais M[i,j] oui
pour un tuple on peut faire voisins.size()?

!!!!!!!!!! A 0 et quand √ßa deborde mon modele renvoie quand meme des valeurs 

//Gerer le cas ou s w peut etre majuscule ou miniscule.
//Pour les dictionnaires si la cl√© n'existe pas on peut utiliser la fonction get pour retourner une valeur par defaut 
valeur = get(d, "cinq", 0)  # Retourne 0 si "cinq" n'est pas dans le dictionnaire
println(valeur).

***Dans ce projet on utilisera les dictionnaires en plus des set pour:
Enregistrer les distances : associ√©s √† chaque noeud sa distance minimale depuis la source.
Conserver les predecesseurs: Stocker le noeud parent pour chaque noeud visit√©, ce qui permettra de reconstruire le chemin une fois la destination atteinte .
Stocker d'autres infos(peut etre) comme des √©tats ou des poids. 

******** L'ordre d'evaluation peut ameliorer la performance du BFS*********


gerer les depassements: function algoBFS(fname::String, D::Tuple{Int,Int}, A::Tuple{Int,Int})
    grid = lire_map(fname)
    rows, cols = size(grid)

    # V√©rifier si les positions D et A sont valides
    if !(1 ‚â§ D[1] ‚â§ rows && 1 ‚â§ D[2] ‚â§ cols)
        error("Position de d√©part D = $D hors des limites de la carte ($rows x $cols).")
    end
    if !(1 ‚â§ A[1] ‚â§ rows && 1 ‚â§ A[2] ‚â§ cols)
        error("Position d'arriv√©e A = $A hors des limites de la carte ($rows x $cols).")
    end
    if grid[D...] == '@' || grid[A...] == '@'
        error("D ou A est un obstacle '@' ! Impossible de commencer ou d‚Äôarriver ici.")
    end
affichage aussi comme √ßa: üõ§Ô∏è Chemin : (1,2) ‚Üí (1,3) ‚Üí (2,3) ‚Üí (3,3) ‚Üí (3,4)



# BFS algorithm in Python


import collections

# BFS algorithm
def bfs(graph, root):

    visited, queue = set(), collections.deque([root])
    visited.add(root)

    while queue:

        # Dequeue a vertex from queue
        vertex = queue.popleft()
        print(str(vertex) + " ", end="")

        # If not visited, mark it as visited, and
        # enqueue it
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                visited.add(neighbour)
                queue.append(neighbour)


if __name__ == '__main__':
    graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
    print("Following is Breadth First Traversal: ")
    bfs(graph, 0)
Dijkstra:
Une file de priorit√© permet d'explorer d'abord les chemins les moins couteux.
push!(visited,current)
 for nb in get_neighbors(grid, current)
            cost = cout_deplacement(grid[nb[1], nb[2]])
                          new_dist = dist[current] + cost
            if new_dist < dist[nb]
                dist[nb] = new_dist
                parent[nb] = current
                enqueue!(pq, nb, new_dist)
            end
        end
    end
            Marquage comme visit√© :
        On ajoute la case current dans l‚Äôensemble visited pour signifier que son co√ªt est maintenant fix√©.

        It√©ration sur les voisins :
        Pour chaque voisin accessible (d√©termin√© par ta fonction get_neighbors), on fait :
            On calcule le co√ªt pour aller de current √† ce voisin gr√¢ce √† cout_deplacement.
            new_dist correspond au co√ªt cumul√© pour atteindre ce voisin en passant par current (soit le co√ªt pour atteindre current plus le co√ªt du mouvement vers le voisin).
            Mise √† jour de la distance :
            Si new_dist est inf√©rieur au co√ªt actuellement enregistr√© pour ce voisin, cela signifie qu‚Äôon a trouv√© un chemin moins co√ªteux.
            On met donc √† jour dist[nb], on enregistre current comme parent de ce voisin, et on l‚Äôajoute dans la PriorityQueue avec la nouvelle priorit√© (new_dist).
            En BFS, on explore chaque n≈ìud exactement une fois gr√¢ce √† un set "visited" qui emp√™che de retraiter un m√™me n≈ìud. Dans Dijkstra, un n≈ìud peut √™tre ins√©r√© plusieurs fois dans la PriorityQueue avec des co√ªts diff√©rents, car on peut d√©couvrir plusieurs chemins pour y arriver. Cependant, d√®s qu'un n≈ìud est extrait et marqu√© comme visit√© (c'est-√†-dire que son co√ªt minimal est d√©finitivement fix√©), il ne sera plus trait√©, m√™me s'il appara√Æt plusieurs fois dans la file.
    Mise √† jour des distances :
    Lorsqu'on trouve un chemin plus court vers un n≈ìud d√©j√† rencontr√©, on met √† jour sa distance et on l'ajoute √† la file de priorit√© avec cette nouvelle valeur. Ainsi, le m√™me n≈ìud peut √™tre extrait plusieurs fois, mais g√©n√©ralement, lorsqu'il est extrait, on v√©rifie si la distance associ√©e est toujours la plus courte. Si ce n'est pas le cas, on l'ignore.

    Comparaison avec BFS :
    Dans un BFS classique sur un graphe non pond√©r√©, on marque un n≈ìud comme visit√© d√®s qu'on l'ajoute √† la file. Cela garantit que chaque n≈ìud est examin√© une seule fois. En revanche, Dijkstra travaille avec des poids et doit parfois r√©examiner un n≈ìud pour mettre √† jour la meilleure distance trouv√©e.

En r√©sum√©, la nature des mises √† jour dans Dijkstra implique que le m√™me n≈ìud peut √™tre trait√© √† plusieurs reprises, alors qu'en BFS, une fois qu'un n≈ìud est visit√©, il n'est plus r√©examin√©.



